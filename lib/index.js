// Generated by CoffeeScript 1.7.1
var COLLECTION_RECYCLE_INTERVAL, COLLECTION_RECYCLE_QUATITY, COLLECTION_RECYCLE_TARGET, COLLECTION_TTL, Nohm, Recore, assert, extend, hasher, recycle, schemas,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Nohm = require("nohm").Nohm;

assert = require('assert');

hasher = require('./hasher');

schemas = {};

extend = function() {
  var dest, k, obj, objs, v, _i, _len;
  dest = arguments[0], objs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = objs.length; _i < _len; _i++) {
    obj = objs[_i];
    for (k in obj) {
      v = obj[k];
      dest[k] = v;
    }
  }
  return dest;
};

recycle = function() {
  var ids;
  ids = Object.keys(Recore.collections);
  if (ids.length > COLLECTION_RECYCLE_TARGET) {
    ids = ids.slice(0, COLLECTION_RECYCLE_QUATITY);
    ids.forEach(function(name) {
      return delete Recore.collections[name];
    });
  }
  return setTimeout(recycle, COLLECTION_RECYCLE_INTERVAL);
};

COLLECTION_TTL = 300000;

COLLECTION_RECYCLE_INTERVAL = 600000;

COLLECTION_RECYCLE_QUATITY = 1000;

COLLECTION_RECYCLE_TARGET = 10000;

setTimeout(recycle, COLLECTION_RECYCLE_INTERVAL);

Recore = (function(_super) {
  __extends(Recore, _super);

  function Recore() {
    return Recore.__super__.constructor.apply(this, arguments);
  }

  Recore.collections = {};

  Recore.base_models = {};

  Recore.getClient = function() {
    return Recore.client;
  };

  Recore.getModel = function(name) {
    return this.getModels()[name];
  };

  Recore.getBaseModels = function() {
    return this.base_models;
  };

  Recore.getBaseModel = function(name) {
    return this.getBaseModels()[name];
  };

  Recore.configure = function(options) {
    var filename, _i, _len, _ref;
    assert(options && options.redis, "Set redis client first");
    options.redis.connected = true;
    this.setClient(options.redis);
    this.setPrefix(options.prefix);
    Recore.prefix = Nohm.prefix;
    Recore.client = Nohm.client;
    if (options.models) {
      if (options.models.charAt(0) !== "/") {
        options.models = require('path').dirname(module.parent.filename) + "/" + options.models;
      }
      _ref = require('fs').readdirSync(options.models);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filename = _ref[_i];
        require(options.models + "/" + filename);
      }
    }
    return Recore;
  };

  Recore.model = function(name, options, temp) {
    var collections, model;
    schemas[name] = options;
    if (options.methods == null) {
      options.methods = {};
    }
    if (options["extends"] == null) {
      options["extends"] = {};
    }
    options.methods = extend(options.methods, this._methods);
    model = Nohm.model(name, options, temp);
    model = extend(model, this._extends, options["extends"]);
    model.modelName = name;
    this.base_models[name] = model;
    model.collectionDefinition = options.properties.collections || null;
    if (model.collectionDefinition) {
      if (Array.isArray(model.collectionDefinition)) {
        collections = model.collectionDefinition;
      } else if (typeof model.collectionDefinition === 'object') {
        collections = Object.keys(model.collectionDefinition);
      } else {
        throw new Error("wrong type of collection definition");
      }
      collections.forEach(function(key) {
        return model.collection(key);
      });
    }
    model.__findAndLoad = model.findAndLoad;
    model.findAndLoad = function(searches, callback) {
      if (typeof searches === 'function') {
        callback = searches;
        searches = {};
      }
      return model.__findAndLoad.call(model, searches, callback);
    };
    model.__find = model.find;
    model.find = function(searches, callback) {
      if (this.getClient().shardable && searches && typeof searches !== 'function' && Object.keys(searches).length > 1) {
        throw new Error("cannot search more one criteria with redism");
      }
      return model.__find.apply(this, arguments);
    };
    model.__sort = model.sort;
    model.sort = function(options, ids) {
      var arg, args, callback, count, direction, field_type, ins, offset, scored, _i, _len;
      if (typeof options === 'object' && options.field === 'id') {
        if (options.limit == null) {
          options.limit = [0, 100];
        }
        offset = options.limit[0];
        count = options.limit[1];
        direction = options.direction || 'DESC';
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          if (typeof arg === 'function') {
            callback = arg;
            break;
          }
        }
        if (callback == null) {
          callback = function(err, ids) {};
        }
        args = [];
        return model.getClient().sort(model.getIdsetsKey(), "LIMIT", offset, count, direction, callback.bind(model));
      }
      ins = new model;
      if (this.getClient().shardable) {
        field_type = ins.properties[options.field].type;
        scored = Recore.indexNumberTypes.indexOf(field_type) !== -1;
        if (!scored) {
          throw new Error("cannot sort on non-numeric fields with redism");
        }
        if (Array.isArray(ids)) {
          if (!Array.isArray(ids)) {
            throw new Error("cannot sort on subset with redism");
          }
        }
      }
      return model.__sort.apply(this, arguments);
    };
    return model;
  };

  Recore._methods = {};

  Recore._extends = {
    collection: function(key) {
      var collection, model, name;
      name = "" + this.modelName + ":collection:" + key;
      collection = Recore.collections[name];
      if (!collection) {
        model = this;
        collection = Recore.model(name, schemas[model.modelName]);
        collection.modelName = name;
        collection.prototype.modelName = name;
        Recore.collections[name] = collection;
      }
      return collection;
    },
    getClient: function() {
      return Recore.prototype.getClient();
    },
    getIdsKey: function() {
      return "" + Recore.prefix.ids + this.modelName;
    },
    getIdsetsKey: function() {
      return "" + Recore.prefix.idsets + this.modelName;
    },
    getHashKey: function(id) {
      return "" + Recore.prefix.hash + this.modelName + ":" + id;
    },
    getScoredIndexKey: function(field) {
      return "" + Recore.prefix.scoredindex + this.modelName + ":" + field;
    },
    getIndexKey: function(field, value) {
      return "" + Recore.prefix.index + this.modelName + ":" + field + ":" + value;
    },
    getUniqueIndexKey: function(field, value) {
      return "" + Recore.prefix.unique + this.modelName + ":" + field + ":" + value;
    },
    get: function(criteria, callback) {
      return this.findAndLoad(criteria, function(err, objs) {
        if (err) {
          return callback(err);
        }
        if (objs.length === 1) {
          return callback.call(objs[0], null, objs[0].allProperties());
        } else {
          return callback.call(null, objs);
        }
      });
    },
    find_or_create: function(criteria, callback) {
      var model;
      model = this;
      return this.find(criteria, (function(_this) {
        return function(err, ids) {
          var new_obj;
          if (err === 'not found' || ids.length === 0) {
            new_obj = new model;
            new_obj.prop(criteria);
            return callback(null, new_obj);
          }
          if (err) {
            return callback(err);
          }
          if (ids.length > 1) {
            return callback("more than one");
          }
          return _this.load(ids.pop(), function(err, props) {
            if (err) {
              return callback(err);
            }
            return callback(null, this);
          });
        };
      })(this));
    },
    ids: function(ids, callback) {
      var count, id, rows, total, _i, _len, _results;
      if (ids.length === 0) {
        return callback(null, []);
      }
      rows = [];
      count = 0;
      total = ids.length;
      _results = [];
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        id = ids[_i];
        _results.push(this.load(parseInt(id), function(err, props) {
          if (err) {
            return callback(err);
          }
          rows.push(this.allProperties());
          count++;
          if (count === total) {
            return callback(null, rows);
          }
        }));
      }
      return _results;
    },
    count: function(criteria, callback) {
      var m;
      if (typeof criteria === 'function') {
        callback = criteria;
        criteria = null;
        m = new this;
        return this.getClient().scard(Recore.prefix.idsets + m.modelName, function(err, result) {
          if (err) {
            return callback(err);
          }
          return callback(null, result);
        });
      }
      return this.find(criteria, function(err, ids) {
        if (err) {
          return callback(err);
        }
        return callback(null, ids.length);
      });
    },
    create_index: function(property, callback) {
      var affected_rows, model, multi, new_unique, old_unique;
      if (typeof property === "function") {
        callback = property;
        property = null;
      }
      model = this;
      multi = this.getClient().multi();
      affected_rows = 0;
      old_unique = [];
      new_unique = [];
      return this.find((function(_this) {
        return function(err, ids) {
          if (err || ids.length < 1) {
            return callback.call(model, err, affected_rows);
          }
          return ids.forEach(function(id, idx) {
            return _this.load(id, function(err, props) {
              var def, p, set_update, _ref;
              if (err) {
                console.log(id, this.errors);
              }
              set_update = (function(_this) {
                return function(prop) {
                  var propLower;
                  if (_this.properties[prop].unique) {
                    propLower = _this.properties[prop].type === 'string' ? _this.properties[prop].__oldValue.toLowerCase() : _this.properties[prop].__oldValue;
                    return multi.setnx("" + Recore.prefix.unique + _this.modelName + ":" + prop + ":" + _this.properties[prop].value, id);
                  } else {
                    return _this.properties[prop].__updated = true;
                  }
                };
              })(this);
              if (property) {
                set_update(property);
              } else {
                _ref = this.properties;
                for (p in _ref) {
                  def = _ref[p];
                  if (def.index || def.unique) {
                    set_update(p);
                  }
                }
              }
              return this.save(function(err) {
                console.log("Indexed " + this.modelName + " on '" + (property || 'all indexed properties') + "' for row id " + this.id);
                affected_rows += 1;
                if (idx === ids.length - 1) {
                  multi.exec();
                  return callback.call(model, err, affected_rows);
                }
              });
            });
          });
        };
      })(this));
    },
    remove_index: function(properties, callback) {
      var def, deletes, ins, model, multi, p, _ref;
      model = this;
      multi = this.getClient().multi();
      deletes = [];
      if (typeof properties === 'function') {
        callback = properties;
        properties = null;
      }
      if (typeof properties === 'string') {
        properties = [properties];
      }
      if (!properties) {
        ins = new model;
        properties = [];
        _ref = ins.properties;
        for (p in _ref) {
          def = _ref[p];
          if (def.index || def.unique) {
            properties.push(p);
          }
        }
      }
      return properties.forEach((function(_this) {
        return function(p, idx) {
          return Recore.client.keys("" + Recore.prefix.unique + _this.modelName + ":" + p + ":*", function(err, unique_keys) {
            deletes = unique_keys;
            return Recore.client.keys("" + Recore.prefix.index + _this.modelName + ":" + p + ":*", function(err, index_keys) {
              deletes = deletes.concat(index_keys);
              return Recore.client.keys("" + Recore.prefix.scoredindex + _this.modelName + ":" + p + ":*", function(err, scoredindex_keys) {
                deletes = deletes.concat(scoredindex_keys);
                if (idx === properties.length - 1) {
                  if (deletes.length > 0) {
                    multi.del(deletes);
                  }
                  return multi.exec(function(err, results) {
                    console.log("Deleted " + deletes.length + " related keys for '" + (properties.join(', ')) + "' of " + _this.modelName);
                    return callback.call(model, err, deletes.length);
                  });
                }
              });
            });
          });
        };
      })(this));
    },
    remove_property: function(callback) {
      var affected_rows, deletes, model, multi, undefined_properties;
      model = new this;
      multi = Recore.client.multi();
      deletes = [];
      affected_rows = 0;
      undefined_properties = [];
      return this.find((function(_this) {
        return function(err, ids) {
          if (err || ids.length < 1) {
            return callback.call(_this, err, affected_rows);
          }
          return ids.forEach(function(id, idx) {
            return _this.getClient().hgetall(_this.getHashKey(id), function(err, values) {
              var is_enumerable, is_meta, is_property, keys, p;
              keys = values ? Object.keys(values) : [];
              if (!(Array.isArray(keys) && keys.length > 0 && !err)) {
                err = 'not found';
              }
              if (err) {
                Recore.logError("loading a hash produced an error: " + err);
                return callback != null ? callback.call(_this, err) : void 0;
              }
              for (p in values) {
                is_enumerable = values.hasOwnProperty(p);
                is_meta = p === '__meta_version';
                is_property = model.properties.hasOwnProperty(p);
                if (!is_meta && !model.properties.hasOwnProperty(p)) {
                  affected_rows += 1;
                  if (undefined_properties.indexOf(p) === -1) {
                    Recore.logError("Undefined property '" + p + "' found, will be deleted");
                    undefined_properties.push(p);
                  }
                  multi.hdel(_this.getHashKey(id), p);
                }
              }
              if (idx === ids.length - 1) {
                if (!(undefined_properties.length > 0)) {
                  return callback.call(model, err, affected_rows);
                }
                multi.exec(function(err, results) {
                  return console.log("Cleaned up undefined properties " + (undefined_properties.join(', ')));
                });
                return _this.deindex(undefined_properties, callback);
              }
            });
          });
        };
      })(this));
    }
  };

  Recore._methods = null;

  return Recore;

})(Nohm);

module.exports = Recore;
