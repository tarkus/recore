// Generated by CoffeeScript 1.7.1
var COLLECTION_RECYCLE_INTERVAL, COLLECTION_RECYCLE_QUATITY, COLLECTION_RECYCLE_TARGET, COLLECTION_TTL, EventEmitter, Nohm, Recore, assert, extend, hasher, recycle, schemas,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Nohm = require("nohm").Nohm;

assert = require('assert');

hasher = require('./hasher');

EventEmitter = require('events').EventEmitter;

schemas = {};

extend = function() {
  var dest, k, obj, objs, v, _i, _len;
  dest = arguments[0], objs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = objs.length; _i < _len; _i++) {
    obj = objs[_i];
    for (k in obj) {
      v = obj[k];
      dest[k] = v;
    }
  }
  return dest;
};

recycle = function() {
  var ids;
  ids = Object.keys(Recore.collections);
  if (ids.length > COLLECTION_RECYCLE_TARGET) {
    ids = ids.slice(0, COLLECTION_RECYCLE_QUATITY);
    ids.forEach(function(name) {
      return delete Recore.collections[name];
    });
  }
  return setTimeout(recycle, COLLECTION_RECYCLE_INTERVAL);
};

COLLECTION_TTL = 300000;

COLLECTION_RECYCLE_INTERVAL = 600000;

COLLECTION_RECYCLE_QUATITY = 1000;

COLLECTION_RECYCLE_TARGET = 10000;

setTimeout(recycle, COLLECTION_RECYCLE_INTERVAL);

Recore = (function(_super) {
  __extends(Recore, _super);

  function Recore() {
    return Recore.__super__.constructor.apply(this, arguments);
  }

  Recore.collections = {};

  Recore.base_models = {};

  Recore.getClient = function() {
    return Recore.client;
  };

  Recore.getModel = function(name) {
    return this.getModels()[name];
  };

  Recore.getBaseModels = function() {
    return this.base_models;
  };

  Recore.getBaseModel = function(name) {
    return this.getBaseModels()[name];
  };

  Recore.configure = function(options) {
    var filename, _i, _len, _ref;
    assert(options && options.redis, "Set redis client first");
    options.redis.connected = true;
    this.setClient(options.redis);
    this.setPrefix(options.prefix);
    Recore.prefix = Nohm.prefix;
    Recore.client = Nohm.client;
    if (options.models) {
      if (options.models.charAt(0) !== "/") {
        options.models = require('path').dirname(module.parent.filename) + "/" + options.models;
      }
      _ref = require('fs').readdirSync(options.models);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filename = _ref[_i];
        require(options.models + "/" + filename);
      }
    }
    return Recore;
  };

  Recore.model = function(name, options, temp) {
    var attributes, collections, model, _base, _base1;
    schemas[name] = options;
    if (options.methods == null) {
      options.methods = {};
    }
    if (options["extends"] == null) {
      options["extends"] = {};
    }
    if (options.attr_accessible == null) {
      options.attr_accessible = [];
    }
    attributes = function() {
      var attr, output, _i, _len, _ref;
      output = {};
      _ref = options.attr_accessible;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        output[attr] = this.prop(attr);
      }
      return output;
    };
    if (options.methods.attributes != null) {
      options.methods._super_attributes = attributes;
    } else {
      options.methods.attributes = attributes;
    }
    if ((_base = options.methods).attr == null) {
      _base.attr = options.methods.attributes;
    }
    if ((_base1 = options.methods).attrs == null) {
      _base1.attrs = options.methods.attributes;
    }
    options.methods = extend(options.methods, this._methods);
    model = Nohm.model(name, options, temp);
    model = extend(model, this._extends, options["extends"]);
    model.modelName = name;
    model.isCollection = false;
    this.base_models[name] = model;
    model.collectionDefinition = options.properties.collections || null;
    if (model.collectionDefinition) {
      if (Array.isArray(model.collectionDefinition)) {
        collections = model.collectionDefinition;
      } else if (typeof model.collectionDefinition === 'object') {
        collections = Object.keys(model.collectionDefinition);
      } else {
        throw new Error("wrong type of collection definition");
      }
      collections.forEach(function(key) {
        return model.collection(key);
      });
    }
    model.__findAndLoad = model.findAndLoad;
    model.findAndLoad = function(searches, callback) {
      if (typeof searches === 'function') {
        callback = searches;
        searches = {};
      }
      return model.__findAndLoad.call(model, searches, callback);
    };
    model.__find = model.find;
    model.find = function(searches, callback) {
      if (this.getClient().shardable && searches && typeof searches !== 'function' && Object.keys(searches).length > 1) {
        throw new Error("cannot search more one criteria with redism");
      }
      return model.__find.apply(this, arguments);
    };
    model.__sort = model.sort;
    model.sort = function(options, ids) {
      var arg, args, callback, count, direction, field_type, ins, offset, scored, _i, _len;
      if (typeof options === 'object' && options.field === 'id') {
        if (options.limit == null) {
          options.limit = [0, 100];
        }
        offset = options.limit[0];
        count = options.limit[1];
        direction = options.direction || 'DESC';
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          if (typeof arg === 'function') {
            callback = arg;
            break;
          }
        }
        if (callback == null) {
          callback = function(err, ids) {};
        }
        args = [];
        return model.getClient().sort(model.getIdsetsKey(), "LIMIT", offset, count, direction, function(err, ids) {
          if (!err) {
            return callback.apply(model, arguments);
          }
          return model.getClient().sort(model.getIdsetsKey(), "ALPHA", "LIMIT", offset, count, direction, function(err, ids) {
            return callback.apply(model, arguments);
          });
        });
      }
      ins = new model;
      if (this.getClient().shardable) {
        field_type = ins.properties[options.field].type;
        scored = Recore.indexNumberTypes.indexOf(field_type) !== -1;
        if (!scored) {
          throw new Error("cannot sort on non-numeric fields with redism");
        }
        if (Array.isArray(ids)) {
          if (!Array.isArray(ids)) {
            throw new Error("cannot sort on subset with redism");
          }
        }
      }
      return model.__sort.apply(this, arguments);
    };
    return model;
  };

  Recore._methods = {};

  Recore._extends = {
    collection: function() {
      var collection, key, keys, model, name;
      keys = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      assert(keys.length > 0, "Key for collection cannot be empty");
      key = keys.join('+');
      name = "" + this.modelName + ":collection:" + key;
      collection = Recore.collections[name];
      if (!collection) {
        model = this;
        collection = Recore.model(name, schemas[model.modelName]);
        collection.modelName = name;
        collection.prototype.modelName = name;
        collection.isCollection = true;
        Recore.collections[name] = collection;
      }
      return collection;
    },
    getClient: function() {
      return Recore.prototype.getClient();
    },
    getIdsKey: function() {
      return "" + Recore.prefix.ids + this.modelName;
    },
    getIdsetsKey: function() {
      return "" + Recore.prefix.idsets + this.modelName;
    },
    getHashKey: function(id) {
      return "" + Recore.prefix.hash + this.modelName + ":" + id;
    },
    getScoredIndexKey: function(field) {
      return "" + Recore.prefix.scoredindex + this.modelName + ":" + field;
    },
    getIndexKey: function(field, value) {
      return "" + Recore.prefix.index + this.modelName + ":" + field + ":" + value;
    },
    getUniqueIndexKey: function(field, value) {
      if (isNaN(value)) {
        value = value.toLowerCase();
      }
      return "" + Recore.prefix.unique + this.modelName + ":" + field + ":" + value;
    },
    get: function(criteria, callback) {
      return this.findAndLoad(criteria, function(err, objs) {
        if (err) {
          return callback(err);
        }
        if (objs.length === 1) {
          return callback.call(objs[0], null, objs[0].allProperties());
        } else {
          return callback.call(null, objs);
        }
      });
    },
    find_or_create: function(criteria, callback) {
      var model;
      model = this;
      return this.find(criteria, (function(_this) {
        return function(err, ids) {
          var new_obj;
          if (err === 'not found' || ids.length === 0) {
            new_obj = new model;
            new_obj.prop(criteria);
            return callback(null, new_obj);
          }
          if (err) {
            return callback(err);
          }
          if (ids.length > 1) {
            return callback("more than one");
          }
          return _this.load(ids.pop(), function(err, props) {
            if (err) {
              return callback(err);
            }
            return callback(null, this);
          });
        };
      })(this));
    },
    ids: function(ids, callback) {
      var count, id, rows, total, _i, _len, _results;
      if (ids.length === 0) {
        return callback(null, []);
      }
      rows = [];
      count = 0;
      total = ids.length;
      _results = [];
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        id = ids[_i];
        _results.push(this.load(parseInt(id), function(err, props) {
          if (err) {
            return callback(err);
          }
          rows.push(this.allProperties());
          count++;
          if (count === total) {
            return callback(null, rows);
          }
        }));
      }
      return _results;
    },
    count: function(criteria, callback) {
      var m;
      if (typeof criteria === 'function') {
        callback = criteria;
        criteria = null;
        m = new this;
        return this.getClient().scard(this.getIdsetsKey(), function(err, result) {
          if (err) {
            return callback(err);
          }
          return callback(null, result);
        });
      }
      return this.find(criteria, function(err, ids) {
        if (err) {
          return callback(err);
        }
        return callback(null, ids.length);
      });
    },
    create_index: function(field) {
      var batch, batch_size, count, error_handler, event, index, model, run;
      event = new EventEmitter;
      model = this;
      count = 0;
      batch = 1;
      batch_size = 100;
      error_handler = function(err) {
        if (err) {
          return event.emit('error');
        }
      };
      index = function(field) {
        var key, prop;
        prop = this.properties[field];
        if (prop.index) {
          if (prop.__numericIndex) {
            key = model.getScoredIndexKey(field);
            model.getClient().zadd(key, prop.value, this.id, error_handler);
          } else {
            key = model.getIndexKey(field, prop.value);
            model.getClient().sadd(key, this.id, error_handler);
          }
        }
        if (prop.unique) {
          key = model.getUniqueIndexKey(field, prop.value);
          return model.getClient().setnx(key, this.id, error_handler);
        }
      };
      run = function() {
        event.emit('checkpoint', count);
        return model.sort({
          field: 'id',
          direction: 'ASC',
          limit: [(batch - 1) * batch_size, batch_size]
        }, function(err, ids) {
          var batch_count, batch_total, id, _i, _len, _results;
          if (err) {
            return event.emit('halt', err);
          }
          if (ids.length === 0) {
            return event.emit('done', count);
          }
          batch_count = 0;
          batch_total = ids.length;
          batch++;
          _results = [];
          for (_i = 0, _len = ids.length; _i < _len; _i++) {
            id = ids[_i];
            _results.push((function(id) {
              return model.load(id, function(err, props) {
                var property, _ref;
                count++;
                batch_count++;
                if (err) {
                  event.emit('error');
                } else {
                  if (field) {
                    index.call(this, field);
                  } else {
                    _ref = this.properties;
                    for (field in _ref) {
                      property = _ref[field];
                      index.call(this, field);
                    }
                  }
                }
                if (batch_count === batch_total) {
                  return event.emit('next');
                }
              });
            })(id));
          }
          return _results;
        });
      };
      model.count(function(err, count) {
        if (err) {
          return event.emit('halt', err);
        }
        event.emit('objects', count);
        event.on('next', run);
        return run();
      });
      return event;
    },
    remove_index: function(field) {
      var batch_size, clients, count, event, finished_clients, idx, keys, patterns, scan, total;
      event = new EventEmitter;
      if (!field) {
        event.emit('halt', 'no field specified');
      }
      patterns = {
        index: this.getIndexKey(field, '*'),
        scoredindex: this.getScoredIndexKey(field, '*'),
        uniques: this.getUniqueIndexKey(field, '*')
      };
      count = 0;
      total = 0;
      batch_size = 100;
      finished_clients = [];
      idx = 0;
      keys = Object.keys(patterns);
      clients = Object.keys(Recore.getClient().clients);
      scan = function(client, pattern, cursor) {
        if (cursor == null) {
          cursor = 0;
        }
        event.emit('checkpoint', count);
        return client.scan(cursor, 'MATCH', pattern, 'COUNT', batch_size, function(err, result) {
          var args, batch_count, matches;
          if (err) {
            return event.emit('halt', err);
          }
          cursor = result[0], matches = result[1];
          if (parseInt(cursor) === 0) {
            return event.emit('end', client);
          }
          batch_count = matches.length;
          if (batch_count > 0) {
            total += batch_count;
            event.emit('objects', total);
            args = keys.push(function(err, result) {
              if (err) {
                event.emit('error', err);
              }
              return count += batch_count;
            });
            client.del(args);
          }
          return event.emit('next', client, pattern, cursor);
        });
      };
      event.on('next', function() {
        return scan.apply(this, arguments);
      });
      event.on('end', function(client) {
        finished_clients.push(client);
        if (finished_clients.length === clients.length) {
          return event.emit('finish');
        }
      });
      event.on('finish', function() {
        return event.emit('run');
      });
      event.on('run', function() {
        var client, dsn, key, pattern, _fn, _ref;
        if (idx === keys.length) {
          return event.emit('done', count);
        }
        key = keys[idx];
        pattern = patterns[key];
        finished_clients = [];
        _ref = Recore.getClient().clients;
        _fn = function(client, pattern) {
          return scan(client, pattern);
        };
        for (dsn in _ref) {
          client = _ref[dsn];
          _fn(client, pattern);
        }
        return idx++;
      });
      event.emit('run');
      return event;
    },
    remove_property: function(field) {
      var batch_size, clients, count, event, finished_clients, pattern, remove_index_event, scan, total;
      event = new EventEmitter;
      if (!field) {
        event.emit('halt', 'no field specified');
      }
      pattern = this.getHashKey(field, '*');
      count = 0;
      total = 0;
      batch_size = 100;
      finished_clients = [];
      clients = Object.keys(Recore.getClient().clients);
      scan = function(client, pattern, cursor) {
        if (cursor == null) {
          cursor = 0;
        }
        event.emit('checkpoint', count);
        return client.scan(cursor, 'MATCH', pattern, 'COUNT', batch_size, function(err, result) {
          var batch_count, matches;
          if (err) {
            return event.emit('halt', err);
          }
          cursor = result[0], matches = result[1];
          if (parseInt(cursor) === 0) {
            return event.emit('end', client, pattern);
          }
          batch_count = matches.length;
          if (batch_count > 0) {
            total += batch_count;
            event.emit('objects', total);
            keys.forEach(function(key) {
              return client.hdel(key, field, function(err, result) {
                if (err) {
                  event.emit('error');
                }
                return count++;
              });
            });
          }
          return event.emit('next', client, pattern, cursor);
        });
      };
      event.on('next', function() {
        return scan.apply(this, arguments);
      });
      event.on('end', function(client, pattern) {
        finished_clients.push(client);
        if (finished_clients.length === clients.length) {
          return event.emit('done', count);
        }
      });
      event.on('run', function() {
        var client, dsn, _ref, _results;
        finished_clients = [];
        _ref = Recore.getClient().clients;
        _results = [];
        for (dsn in _ref) {
          client = _ref[dsn];
          _results.push((function(client, pattern) {
            return scan(client, pattern);
          })(client, pattern));
        }
        return _results;
      });
      remove_index_event = this.remove_index(field);
      remove_index_event.on('done', function() {
        return event.emit('run');
      });
      return event;
    }
  };

  Recore._methods = null;

  return Recore;

})(Nohm);

module.exports = Recore;
